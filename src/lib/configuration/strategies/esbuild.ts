import path from 'path';

import { TsconfigPathsPlugin } from '@esbuild-plugins/tsconfig-paths';
import * as esbuild from 'esbuild';
import fs from 'fs-extra';
import currentNodeVersion from 'node-version';
import { find } from 'tsconfck';

import log from 'lib/log';

import type { PackageInfo } from 'lib/package';


/**
 * Uses esbuild to transpile the user's configuration file.
 */
export async function esbuildStrategy(filePath: string, pkgInfo: PackageInfo) {
  const fileName = path.basename(filePath);

  const outFileBasename = fileName
    .replace(/\.(ts|tsx)$/, '.js')
    .replace(/\.cts$/, '.cjs')
    .replace(/\.mts$/, '.mjs')
    .replace(/\.jsx$/, '.js');

  const isExplicitCommonJs = fileName.endsWith('.cjs') || fileName.endsWith('.cts');

  const format = isExplicitCommonJs
  ? 'cjs'
  : pkgInfo.json?.type === 'module'
    ? 'esm'
    : 'cjs';

  log.verbose(log.prefix('esbuild'), `Using format: ${log.chalk.bold(format)}`);

  const tempFileName = `.temp-saffron.${outFileBasename}`;
  const tempFilePath = path.join(path.dirname(filePath), tempFileName);

  try {
    const buildOptions: esbuild.BuildOptions = {
      entryPoints: [filePath],
      target: `node${currentNodeVersion.major}`,
      outfile: tempFileName,
      format,
      plugins: [],
      banner: {
        'js': '// This temporary file was generated by @darkobits/saffron and can be safely removed.\n'
      }
    };

    const tsConfigFilePath = await find(filePath);

    if (tsConfigFilePath) {
      log.verbose(log.prefix('esbuild'), `Using TypeScript configuration: ${log.chalk.green(tsConfigFilePath)}`);

      buildOptions.tsconfig = tsConfigFilePath;

      buildOptions.plugins?.push(TsconfigPathsPlugin({
        tsconfig: tsConfigFilePath
      }));
    }

    await esbuild.build(buildOptions);
    const result = await import(tempFilePath);

    return result?.default ?? result;
  } finally {
    if (await fs.exists(tempFilePath)) {
      await fs.remove(tempFilePath);
    }
  }
}
