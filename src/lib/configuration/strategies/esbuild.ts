import path from 'path';

import { TsconfigPathsPlugin } from '@esbuild-plugins/tsconfig-paths';
import * as esbuild from 'esbuild';
import fs from 'fs-extra';
import currentNodeVersion from 'node-version';
import * as tsConfck from 'tsconfck';

import log from 'lib/log';

import type { PackageInfo } from 'lib/package';


/**
 * Uses esbuild to transpile the user's configuration file.
 */
export async function esbuildStrategy(filePath: string, pkgInfo: PackageInfo) {
  const parsedFileName = path.parse(filePath);
  const isExplicitCommonJs = ['.cjs', '.cts'].includes(parsedFileName.ext);
  const isExplicitESM = ['.mjs', '.mts'].includes(parsedFileName.ext);

  const extMap: Record<string, string | undefined> = {
    '.ts': '.js',
    '.tsx': '.js',
    '.cts': '.cjs',
    '.mts': '.mjs',
    '.jsx':' .js',
    '.cjs': '.cjs',
    '.mjs': '.mjs'
  };

  const outExt = extMap[parsedFileName.ext];

  if (!outExt) throw new Error(
    `${log.prefix('strategy:esbuild')} Unable to determine output file extension from input extension: ${parsedFileName.ext}`
  );

  // Determine the output format to use by first honoring any explicit
  // transpilation hints based on file extension, then fall back to relying on
  // the "type" field in package.json.
  const format = isExplicitESM
    ? 'esm'
    : isExplicitCommonJs
      ? 'cjs'
      : pkgInfo.json?.type === 'module'
        ? 'esm'
        : 'cjs';

  log.verbose(log.prefix('strategy:esbuild'), `Using format: ${log.chalk.bold(format)}`);

  const tempFileName = `.${parsedFileName.name}.${Date.now()}${outExt}`;
  const tempFilePath = path.join(path.dirname(filePath), tempFileName);
  log.silly(log.prefix('strategy:esbuild'), `Temporary file will be written to: ${log.chalk.green(tempFilePath)}`);

  try {
    const buildOptions: esbuild.BuildOptions = {
      entryPoints: [filePath],
      target: `node${currentNodeVersion.major}`,
      outfile: tempFileName,
      format,
      plugins: [],
      banner: {
        'js': '/** This file was generated by @darkobits/saffron and can be safely removed. */\n'
      }
    };

    // If the user has a TypeScript configuration file, enable TypeScript
    // features.
    const tsConfigFilePath = await tsConfck.find(filePath);

    if (tsConfigFilePath) {
      log.verbose(log.prefix('strategy:esbuild'), `Using TypeScript configuration: ${log.chalk.green(tsConfigFilePath)}`);
      buildOptions.tsconfig = tsConfigFilePath;
      buildOptions.plugins?.push(TsconfigPathsPlugin({ tsconfig: tsConfigFilePath }));
    }

    // Transpile the input file.
    await esbuild.build(buildOptions);
  } catch (cause: any) {
    throw new Error(
      `${log.prefix('strategy:esbuild')} ${log.chalk.red('Failed to transpile configuration file')} ${log.chalk.green(filePath)}: ${cause}`,
      { cause }
    );
  }

  try {
    // Load the input file.
    const result = await import(tempFilePath);

    // Note: This assumes the consumer wants the default export.
    return result?.default ?? result;
  } catch (cause: any) {
    throw new Error(
      `${log.prefix('strategy:esbuild')} ${log.chalk.red('Failed to load configuration file')} ${log.chalk.green(tempFilePath)}: ${cause}`,
      { cause }
    );
  } finally {
    // Remove the temporary file.
    if (await fs.exists(tempFilePath)) {
      await fs.remove(tempFilePath);
    }
  }
}
