import path from 'path';

import { TsconfigPathsPlugin } from '@esbuild-plugins/tsconfig-paths';
import * as esbuild from 'esbuild';
import fs from 'fs-extra';
import currentNodeVersion from 'node-version';
import * as tsConfck from 'tsconfck';

import log from 'lib/log';

import type { PackageInfo } from 'lib/package';


/**
 * Map of possible config file extensions to the most sensible output format
 * that we can dynamically import without producing an
 * ERR_UNKNOWN_FILE_EXTENSION error from Node.
 */
const EXT_MAP: Record<string, string | undefined> = {
  '.js': '.js',
  '.ts': '.js',
  '.tsx': '.js',
  '.jsx':' .js',
  // User explicitly wants CommonJS.
  '.cts': '.cjs',
  '.cjs': '.cjs',
  // User explicitly wants ESM.
  '.mts': '.mjs',
  '.mjs': '.mjs'
};


/**
 * This strategy uses esbuild to transpile the host package's configuration
 * file. It creates a temporary transpiled configuration file in the same
 * directory as the source file, then attempts to dynamically import it. An
 * output format and extension are chosen based on the host project's
 * configuration that are the least likely to produce errors. Finally, the
 * temporary file is removed.
 */
export async function esbuildStrategy(filePath: string, pkgInfo: PackageInfo) {
  const prefix = log.prefix('strategy:esbuild');
  const parsedFilePath = path.parse(filePath);
  const isExplicitCommonJs = ['.cjs', '.cts'].includes(parsedFilePath.ext);
  const isExplicitESM = ['.mjs', '.mts'].includes(parsedFilePath.ext);

  const outExt = EXT_MAP[parsedFilePath.ext];

  if (!outExt) throw new Error(
    `${prefix} Unable to determine output file extension from input extension: ${parsedFilePath.ext}`
  );

  // Determine the output format to use by first honoring any explicit
  // transpilation hints based on file extension, then fall back to relying on
  // the "type" field in package.json. The aim here is to use an output format
  // that is the least likely to produce errors when being dynamically imported.
  const format = isExplicitESM
    ? 'esm'
    : isExplicitCommonJs
      ? 'cjs'
      : pkgInfo.json?.type === 'module'
        ? 'esm'
        : 'cjs';

  log.verbose(prefix, `Using format: ${log.chalk.bold(format)}`);

  const tempFileName = `.${parsedFilePath.name}.${Date.now()}${outExt}`;
  const tempFilePath = path.join(path.dirname(filePath), tempFileName);
  log.verbose(prefix, `Temporary configuration file: ${log.chalk.green(tempFilePath)}`);

  try {
    const buildOptions: esbuild.BuildOptions = {
      entryPoints: [filePath],
      target: `node${currentNodeVersion.major}`,
      outfile: tempFileName,
      format,
      plugins: [],
      banner: {
        'js': '/** This file was generated by @darkobits/saffron (esbuild) and can be safely removed. */\n'
      }
    };

    // If the user has a TypeScript configuration file, enable TypeScript
    // features.
    const tsConfigFilePath = await tsConfck.find(filePath);

    if (tsConfigFilePath) {
      log.verbose(prefix, 'Using:', log.chalk.green(tsConfigFilePath));
      buildOptions.tsconfig = tsConfigFilePath;
      buildOptions.plugins?.push(TsconfigPathsPlugin({ tsconfig: tsConfigFilePath }));
    }

    // Transpile the input file.
    await esbuild.build(buildOptions);
  } catch (err: any) {
    // Handle any transpilation-related errors.
    throw new Error(
      `${log.chalk.red(`[${prefix}] Failed to transpile configuration file ${filePath}:`)} ${err.message}`,
      { cause: err }
    );
  }

  try {
    // Load the input file.
    const result = await import(tempFilePath);

    // Note: This assumes the consumer wants the default export.
    return result?.default ?? result;
  } catch (err: any) {
    // Handle any import-related errors.
    throw new Error(
      `${log.chalk.red(`[${prefix}] Failed to import() configuration file ${filePath}:`)} ${err.message}`,
      { cause: err }
    );
  } finally {
    // Remove the temporary file.
    if (await fs.exists(tempFilePath)) await fs.remove(tempFilePath);
  }
}
